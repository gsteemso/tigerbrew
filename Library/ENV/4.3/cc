#!/System/Library/Frameworks/Ruby.framework/Versions/Current/usr/bin/ruby -W0

$:.unshift Dir["/System/Library/Frameworks/Ruby.framework/Versions/Current/usr/lib/ruby/{1.8,2.0.0}"].first
require "pathname"
require "set"

if RUBY_VERSION < "1.8.7"
  $:.unshift("#{ENV['HOMEBREW_REPOSITORY']}/Library/Homebrew")
  require 'extend/string'
  require 'vendor/backports/enumerator'
end

class Cmd
  attr_reader :config, :prefix, :cellar, :tmpdir, :sysroot
  attr_reader :archflags, :optflags

  def initialize(arg0, initial_args)
    @arg0 = arg0
    @instance_args = initial_args.freeze
    @config = ENV.fetch("HOMEBREW_CCCFG") { "" }
    @prefix = ENV["HOMEBREW_PREFIX"]
    @cellar = ENV["HOMEBREW_CELLAR"]
    @tmpdir = ENV["HOMEBREW_TEMP"]
    @sysroot = ENV["HOMEBREW_SDKROOT"]
    @archflags = ENV.fetch("HOMEBREW_ARCHFLAGS") { "" }.split(" ")
    @optflags = ENV.fetch("HOMEBREW_OPTFLAGS") { "" }.split(" ")
  end

  def mode
    if @arg0 == "cpp" || @arg0 == "ld"
      @arg0.to_sym
    elsif @instance_args.include? "-c"
      if @arg0 =~ /(?:c|g|clang)\+\+/
        :cxx
      else
        :cc
      end
    elsif @instance_args.include? "-E"
      :ccE
    else
      if @arg0 =~ /(?:c|g|clang)\+\+/
        :cxxld
      else
        :ccld
      end
    end
  end

  def tool
    @tool ||= case @arg0
    when "ld" then "ld"
    when "cpp" then "cpp"
    when /\w\+\+(-\d(\.\d)?)?$/
      case ENV["HOMEBREW_CC"]
      when /clang/
        "clang++"
      when /llvm-gcc/
        "llvm-g++-4.2"
      when /gcc(-\d(\.\d)?)?$/
        "g++" + $1.to_s
      end
    else
      # Note that this is a universal fallback, so that we'll always invoke
      # HOMEBREW_CC regardless of what name under which the tool was invoked.
      ENV["HOMEBREW_CC"]
    end
  end

  def distill_args
    if @instance_args.length == 1 && @instance_args[0] == "-v"
      # Don't add linker arguments if -v passed as sole option. This stops gcc
      # -v with no other arguments from outputting a linker error. Some
      # software uses gcc -v (wrongly) to sniff the GCC version.
      return @instance_args.dup
    end

    if !refurbish_args? || tool == "ld" || configure?
      distilled_args = @instance_args.dup
    else
      distilled_args = refurbished_args
    end

    if sysroot
      if tool == "ld"
        distilled_args << "-syslibroot" << sysroot
      else
        distilled_args << "-isysroot" << sysroot << "--sysroot=#{sysroot}"
      end
    end

    case mode
    when :ccld
      cflags + distilled_args + cppflags + ldflags
    when :cxxld
      cxxflags + distilled_args + cppflags + ldflags
    when :cc
      cflags + distilled_args + cppflags
    when :cxx
      cxxflags + distilled_args + cppflags
    when :ccE
      distilled_args + cppflags
    when :cpp
      distilled_args + cppflags
    when :ld
      ldflags + distilled_args
    end
  end

  def refurbished_args
    @lset = Set.new(library_paths + system_library_paths)
    @iset = Set.new(isystem_paths + include_paths)

    refurbed_args = []
    enum = @instance_args.each

    loop do
      case arg = enum.next
      when "-arch"
        if permit_arch_flags?
          refurbed_args << arg << enum.next
        else
          enum.next
        end
      when "-m32", "-m64"
        refurbed_args << arg if permit_arch_flags?
      when /^-Xarch_/
        refurbished = refurbish_arg(enum.next, enum)
        unless refurbished.empty?
          refurbed_args << arg
          refurbed_args += refurbished
        end
      else
        refurbed_args += refurbish_arg(arg, enum)
      end
    end

    refurbed_args
  end

  def refurbish_arg(arg, enum)
    refurb_arg_parts = []

    case arg
    when /^-g\d?/, /^-gstabs\d+/, "-gstabs+", /^-ggdb\d?/, "-gdwarf-2",
      /^-march=.+/, /^-mtune=.+/, /^-mcpu=.+/,
      /^-O[0-9zs]?$/, "-fast", "-no-cpp-precomp",
      "-pedantic", "-pedantic-errors", "-Wno-long-double",
      "-Wno-unused-but-set-variable"
    when "-Wno-unneeded-internal-declaration"
      refurb_arg_parts << arg if tool =~ /clang/
    when "-fopenmp", "-lgomp", "-mno-fused-madd", "-fforce-addr", "-fno-defer-pop",
      "-mno-dynamic-no-pic", "-fearly-inlining", /^-f(?:no-)?inline-functions-called-once/,
      /^-finline-limit/, /^-f(?:no-)?check-new/, "-fno-delete-null-pointer-checks",
      "-fcaller-saves", "-fthread-jumps", "-fno-reorder-blocks", "-fcse-skip-blocks",
      "-frerun-cse-after-loop", "-frerun-loop-opt", "-fcse-follow-jumps",
      "-fno-regmove", "-fno-for-scope", "-fno-tree-pre", "-fno-tree-dominator-opts",
      "-fuse-linker-plugin"
      # clang doesn't support these flags
      refurb_arg_parts << arg unless tool =~ /^clang/
    when "-Wno-deprecated-register", "-Wno-implicit-fallthrough"
      # older gccs don't support these flags
      refurb_arg_parts << arg unless tool =~ /^g..-4.[02]/
    when /^-W[alp],/, /^-Wno-/
      refurb_arg_parts << arg
    when /^-W.*/
      # prune warnings
    when "-macosx_version_min", "-dylib_install_name"
      refurb_arg_parts << "-Wl,#{arg},#{enum.next}"
    when "-multiply_definedsuppress"
      refurb_arg_parts << "-Wl,-multiply_defined,suppress"
    when "-undefineddynamic_lookup"
      refurb_arg_parts << "-Wl,-undefined,dynamic_lookup"
    when /^-isysroot/, /^--sysroot/
      # We set the sysroot
      enum.next
    when "-dylib"
      refurb_arg_parts << "-Wl,#{arg}"
    when /^-I(.+)?/
      # Support both "-Ifoo" (one argument) and "-I foo" (two arguments)
      val  = chuzzle($1) || enum.next
      path = canonical_path(val)
      refurb_arg_parts << "-I#{val}" if keep?(path) && @iset.add?(path)
    when /^-L(.+)?/
      val  = chuzzle($1) || enum.next
      path = canonical_path(val)
      refurb_arg_parts << "-L#{val}" if keep?(path) && @lset.add?(path)
    else
      refurb_arg_parts << arg
    end

    refurb_arg_parts
  end

  def keep?(path)
    path.start_with?(prefix, cellar, tmpdir) || !path.start_with?("/opt", "/sw", "/usr/X11")
  end

  def cflags
    cflag_args = []

    return cflag_args unless refurbish_args? || configure?

    cflag_args << "-pipe"
    cflag_args << "-w" unless configure?
    cflag_args << "-#{ENV["HOMEBREW_OPTIMIZATION_LEVEL"]}"
    cflag_args.concat(optflags)
    cflag_args.concat(archflags)
    cflag_args << "-std=#{@arg0}" if @arg0 =~ /c[89]9/
    cflag_args
  end

  def cxxflags
    cxxflag_args = cflags
    cxxflag_args << "-std=c++11" if cxx11?
    cxxflag_args << "-stdlib=libc++" if libcxx?
    cxxflag_args << "-stdlib=libstdc++" if libstdcxx?
    cxxflag_args
  end

  def cppflags
    path_flags("-isystem", isystem_paths) + path_flags("-I", include_paths)
  end

  def ldflags
    ldflag_args = path_flags("-L", library_paths)
    case mode
    when :ld
      ldflag_args << "-headerpad_max_install_names"
    when :ccld, :cxxld
      ldflag_args << "-Wl,-headerpad_max_install_names"
    end
    ldflag_args
  end

  def isystem_paths
    path_split("HOMEBREW_ISYSTEM_PATHS")
  end

  def include_paths
    path_split("HOMEBREW_INCLUDE_PATHS")
  end

  def library_paths
    path_split("HOMEBREW_LIBRARY_PATHS")
  end

  def system_library_paths
    %W[#{sysroot}/usr/lib /usr/local/lib]
  end

  def configure?
    # configure scripts generated with autoconf 2.61 or later export as_nl
    ENV.key? "as_nl"
  end

  def refurbish_args?
    config.include?("O")
  end

  def cxx11?
    config.include?("x")
  end

  def libcxx?
    config.include?("g")
  end

  def libstdcxx?
    config.include?("h")
  end

  def permit_arch_flags?
    config.include?("K")
  end

  def canonical_path(path)
    path = Pathname.new(path)
    path = path.realpath if path.exist?
    path.to_s
  end

  def path_flags(prefix, paths)
    paths = paths.uniq.select { |path| File.directory?(path) }
    paths.map! { |path| prefix + path }
  end

  def path_split(key)
    ENV.fetch(key) { "" }.split(File::PATH_SEPARATOR)
  end

  def chuzzle(val)
    return val if val.nil?
    val = val.chomp
    return val unless val.empty?
  end
end

def log(basename, argv, tool, net_args)
  return unless ENV.key?("HOMEBREW_CC_LOG_PATH")

  adds = net_args - argv
  dels = argv - net_args

  s = ""
  s << "#{basename} called with: #{argv.join(" ")}\n"
  s << "superenv removed:  #{dels.join(" ")}\n" unless dels.empty?
  s << "superenv added:    #{adds.join(" ")}\n" unless adds.empty?
  s << "superenv executed: #{tool} #{net_args.join(" ")}\n\n"
  File.open("#{ENV["HOMEBREW_CC_LOG_PATH"]}.cc", "a+") { |f| f.write(s) }
end

if __FILE__ == $PROGRAM_NAME
  ##################################################################### sanity
  abort "The build-tool has reset ENV. --env=std required." unless ENV["HOMEBREW_BREW_FILE"]

  if (cc = ENV["HOMEBREW_CC"]).nil? || cc.empty? || cc == "cc"
    # those values are not allowed
    ENV["HOMEBREW_CC"] = "clang"
  end

  ####################################################################### main

  dirname, basename = File.split($0)

  cmd = Cmd.new(basename, ARGV)
  tool = cmd.tool
  global_args = cmd.distill_args

  log(basename, ARGV, tool, global_args)

  global_args << { :close_others => false } if RUBY_VERSION >= "2.0"
  exec "#{dirname}/xcrun", tool, *global_args
end
